[mathjax]

One of the projets I have wanted to develop for a long time is a browser based particle physics experiment simulator.  Such a project would generate events using Monte Carlo methods and simuate their interactions with the detector.  This was made partly as an educational aid, partly as a challenge to myself, and partly because at the time I was feeling some frustration with the lack of real analysis in my job.  As expected for a Javascript based CPU intensive appplication, this reaches the limits of what is possible with current technology quite rapidly.

<h3>Links</h3>

<a href="http://www.aidansean.com/aDetector/v1/">Live page V1</a>
<a href="http://www.aidansean.com/aDetector/v2/">Live page V2</a>
<a href="http://www.aidansean.com/aDetector/v3/">Live page V3</a>
<a href="http://www.aidansean.com/aDetector/v4/">Live page V4</a>
<a href="http://www.aidansean.com/aDetector/v5/">Live page V5</a>
<a href="https://github.com/aidansean/aDetector">GitHub repository</a>

<h3>Overview</h3>

The model for the detector is saved in an <tt>xml</tt> file which is loaded using the same methods developed in the <a href="http://aidansean.com/projects/?p=235">Marble Hornets</a> project.  Particle data are currently stored in Javascript source files, but will eventually use <tt>xml</tt> as well.  The particle interactions are simulated first by choosing a process (eg \(e^+e^- 	o qar{q}\)) and then decaying the particles.  Jets are formed by popping \(q-ar{q}\) pairs out of the vacuum while phase space allows and then arranging the resulting pairs in hadrons.  Bound states are then decayed according to their <a href="http://pdg.lbl.gov">Particle Data Group (PDG)</a> branching fractions, with phase space decays used.  The paths of the particles are propagated through the detector using a stepwise helix propagation.  Energy depositions in the detector are estimated, according to the characteristic properties of the detector components.  A list of particles is then compiled based on the particles produced and these can be used to reconstruct parent particles.

The user has access to several controls to interact with the application.  They can choose how to view the detector, using Cartesian coordinates and two <a href-"http://en.wikipedia.org/wiki/Aircraft_principal_axes">Euler angles</a> (with the roll axis suppressed.)  The most expensive parts of the process are the generation of the event displays and the generation of the particle table.  By default these are only updated after a certain interval, to allow the user to accumulate a significant number of events without being slowed down by the graphics.  To save time the detector itself is rendered once in a cutaway view, and the particle tracks are overlaid on the saved image.  Eventually the user will be able to get a full event display, including the detector response to the particle with glowing detector components etc.

The user has access to collections of particles, including electrons, muons, pions, kaons, photons, and protons.  From these they can construct other particles, making selections as they do so.  Once they have made parent particles they can then plot kinematic variables including mass, momentum, transverse moment, and helicity angle.  This should, in principle, allow students to learn how to recreate particles and how to separate signal from background effectively.

Given the large amount of information available the user has access to a number of tabs which can can be collapsed out of view.  This allows the user to run the application with the expensive canvas and DOM updates, and thus collect many more events.

This is still a work in progress, with reconstruction of particle being the next main priority.  Eventually the user would be able to load their favourite detector geometry and beam conditions, then perform their analysis, saving the output in <tt>xml</tt> files and possible being able to upload these to a server.  This would allow users to act as "players" with "physics campaigns", including the SPS experiments, HERA experiments, B factories, LEP experiments, and LHC experiments.  This is, of course, a very ambitious goal, and one which has been ongoing for over a year at this point.

See other posts tagged with <a href="http://aidansean.com/projects/?s=aDetector">aDetector</a>.

<h3>Challenges</h3>
<dl>
<dt><em>Challenge</em>: A sophisticated model for the detector was needed.</dt>

<dd><em>Solution</em>: The detector is split up by subdetector, with each subdetector having its own characteristic responses to different particles.  The detector is split up in cylindrical coordinates, \((ho,\eta,\phi)\), with each subdetector also being split into modules.  Individual modules then react the particles for reconstruction purposes.  Thus with a few key parameters even a sophisticated model can be stored in a few variables that can be tuned quickly and easily. (Resolved.)</dd>
<dt><em>Challenge</em>: The detector shold have a three dimensional view that the user can control.</dt>

<dd><em>Solution</em>: The detector is drawn using a wireframe with transparent panels.  This is a method I developed in 2009 for a now defunct PHP generated SVG based visualisation of the BaBar electromagnetic calorimeter, which I used to show the absorbed dose as a function of detector region and time.  The drawing algorithm is not perfect, as panels are drawn in order from furthest from the user to closest.  This is sufficient for most purposes, but occasionally panels will intersect causing strange artefacts.  Eventually this should be replaced with a much more stable, robust, and fast implementation, such as in <a href="http://threejs.org/"><tt>three.js</tt></a>. (Resolved, to be revisited.)</dd>
<dt><em>Challenge</em>: Particles should be modeled realistically and physically correctly.</dt>

<dd><em>Solution</em>: Particles are modelled with the most important parameters (mass, charge, decay modes etc) taken from the PDG.  Their kinematic properties are modeled using special four vector classes, and decay products "inherit" from their parents in a consistent manner.  Particles at the highest layer of the tree are assigned their four momenta, and then their decay products are decayed, inheriting the boost and production vertex from their parents.  This is repeated recursively until all unstable particles are decayed.  So far this does not take spin into account, as everything is decayed using a phase space model.  Particles with large widths have their lineshape modeled using a Breit-Wigner shape.  As a result, particle have realistic looking jets and four momentum is conserved.  This required the development of special libraries to handle these decays and kinematic constraints. (Resolved, to be revisited.)</dd>
<dt><em>Challenge</em>: Particles decay trees must be traversed consistently.</dt>

<dd><em>Solution</em>: This is harder than it sounds!  Every time an event is generated, particles are recursively decayed for as long as phase space allows.  The particles must then be traversed and dispalyed in the table, in a consistent manner.  Ensuring that all particles are listed hierarchally without missing anything out takes some care. (Resolved.)</dd>
<dt><em>Challenge</em>: Particles lists had to be prepared for the user.</dt>

<dd><em>Solution</em>: The user has access to a handful of "building blocks" to play with.  These are taken from the (generated) list of particles per event and filtered by the particle type.  Further lists can be created or filtered from these lists, and parent particles can reconstructed from combining lists.  This means having to provide special classes to handle the particles and ensure that no particles are reconstructed recursively (leading to infinite loops.)  Apart from using reconstructed particles instead of generated particles, this has been resolved. (Resolved, to be revisited.)</dd>
<dt><em>Challenge</em>: The user needs to be able to make histograms.</dt>

<dd><em>Solution</em>: I had made histgorams for other projects, including the <a href="http://aidansean.com/projects/?p=505">Reflections</a> and <a href="http://aidansean.com/projects/?p=81">Box plotter</a> projects, so this was mostly fairly easy to do.  Even so, being able to create new histograms of arbitrary scales and variables on the fly meant that this histogram class had to be more robust than previous projects. (Resolved.)</dd>
</dl>